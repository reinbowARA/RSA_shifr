# RSA_code

В данном репозитории расположен шифратор типа RSA.

Шифр действует по алгоритму ниже:
1. Выберем случайно два простых числа p и q. Для того чтобы алгоритм работал правильно, эти два числа не должны быть равны друг другу. Для того чтобы шифр оказался стойким, эти числа должны быть большими, и для их записи должна использоваться форма целых чисел произвольной точности с размером, по меньшей мере, 1024 бита.
2. Вычислим произведение этих чисел: n = p • q.
3. Вычислим функцию Эйлера (тотиент) для этих двух простых чисел, которая представляется греческой буквой ϕ. Функция эта вычисляется по формуле ϕ = (p –1) • (q –1).
4. Теперь, когда у нас есть значения n и ϕ, сами числа p и q нам болеене нужны. Однако мы должны побеспокоиться о том, чтобы они непопали в чьи-то руки. Их необходимо уничтожить, стерев все следы, поскольку атакующая сторона может по этим числам легко воссоздать нашу пару ключей.
5. Далее мы случайно выбираем число e, большее 1, меньшее ϕ и относительно простое к ϕ. О двух числах говорят, что они относительно просты друг к другу, если у них нет общих простых сомножителей. Обратите внимание, что e не обязательно должно быть простым. Значение e совместно со значением числа n будет представлять собой открытый ключ, используемый для шифрования.
6. Затем мы вычисляем уникальное значение d (оно будет использоваться для дешифрования), которое удовлетворяет следующему условию: если произведение d и e разделить на ϕ, то остаток от деления будет равен 1. Математически это выражается уравнением d • e = 1 (mod ϕ). На математическом жаргоне это звучит так: d есть мультипликативная инверсия от e по модулю ϕ. Значение d теперь должно храниться в секрете. Если вам известно значение j, то значение d легко вычислить из e при помощи метода, называемого алгоритмом Евклида. Если вы знаете n (а это открытое значение), но не знаете p и q (которые уничтожены), то вычислить ϕ чрезвычайно трудно. Значения d и n вместе составляют секретный ключ.

Сгенерировав ключи теперь можно зашифровавать текст.

1. Возьмем положительное число m, представляющее собой фрагмент открытого текста. Для того чтобы алгоритм работал правильно, число m должно быть меньшим, чем модуль числа n, которое ранее было вычислено, как p • q. По этой причине длинные сообщения необходимо разбивать на такие фрагменты, что каждый из них может быть представлен целым числом заданного битового размера, затем каждый фрагмент шифруется индивидуально.
2. Мы вычисляем шифрованный текст c при помощи открытого ключа, состоящего из e и n. Формула, которой мы пользуемся: c = m^e(mod n).

Расшифровать сообщение мы можем по следущим действиям.

1. Мы вычисляем открытый текст при помощи шифрованного текста, а также секретного ключа, состоящего из d и n. Формула, которой мы пользуемся: m = c^d(mod n).
2. Сравниваем полученное m с исходным m и убеждаемся, что они равны, поскольку дешифрование у нас – операция, обращающая шифрование.
